import re
import time
import json
import os
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import run_on_ui_thread, log
from ui.bulletin import BulletinHelper

__id__ = "kastyan_autoreply"
__name__ = "AutoReply by Kastyan"
__description__ = "Автоматический ответ на сообщения выбранных пользователей. Команды: .lock, .unlock, .locklist"
__author__ = "Kastyan"
__version__ = "0.001"
__min_version__ = "11.12.0"
__icon__ = "plugin232/2"

class AutoReplyPlugin(BasePlugin):
    def on_plugin_load(self):
        self.data_file = os.path.join(self.get_data_dir(), "autoreply_data.json")
        self.locked_users = {}
        self.last_reply_time = {}
        self.load_data()
        
        self.add_on_send_message_hook()
        self.add_on_receive_message_hook()
        
    def load_data(self):
        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.locked_users = data.get('users', {})
                    self.last_reply_time = data.get('time', {})
            except Exception as e:
                log(f"AutoReply load error: {e}")

    def save_data(self):
        try:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump({
                    'users': self.locked_users,
                    'time': self.last_reply_time
                }, f, indent=4)
        except Exception as e:
            log(f"AutoReply save error: {e}")

    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        # Обработка команды .lock
        if params.message.startswith('.lock '):
            try:
                args = params.message[6:].split(maxsplit=1)
                if len(args) < 2:
                    BulletinHelper.show_error("Формат: .lock @user текст")
                    return HookResult(strategy=HookStrategy.CANCEL)
                    
                user_id = args[0].strip('@')
                text = args[1]
                
                chat_id = str(params.peer_id)
                if chat_id not in self.locked_users:
                    self.locked_users[chat_id] = {}
                    
                self.locked_users[chat_id][user_id] = text
                self.save_data()
                
                BulletinHelper.show_success(f"Добавлен автоответ для @{user_id}")
                params.message = ""
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
            except Exception as e:
                BulletinHelper.show_error(f"Ошибка: {str(e)}")
                return HookResult(strategy=HookStrategy.CANCEL)

        # Обработка команды .unlock
        elif params.message.startswith('.unlock '):
            try:
                user_id = params.message[8:].strip().strip('@')
                chat_id = str(params.peer_id)
                
                if chat_id in self.locked_users and user_id in self.locked_users[chat_id]:
                    del self.locked_users[chat_id][user_id]
                    self.save_data()
                    BulletinHelper.show_success(f"Удалён автоответ для @{user_id}")
                else:
                    BulletinHelper.show_error("Пользователь не найден")
                    
                params.message = ""
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
            except Exception as e:
                BulletinHelper.show_error(f"Ошибка: {str(e)}")
                return HookResult(strategy=HookStrategy.CANCEL)

        # Обработка команды .locklist
        elif params.message == '.locklist':
            try:
                chat_id = str(params.peer_id)
                if chat_id not in self.locked_users or not self.locked_users[chat_id]:
                    BulletinHelper.show_info("Список пуст")
                else:
                    users = []
                    for uid, text in self.locked_users[chat_id].items():
                        users.append(f"@{uid}: {text}")
                    BulletinHelper.show_info("Автоответы:\n" + "\n".join(users))
                    
                params.message = ""
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
            except Exception as e:
                BulletinHelper.show_error(f"Ошибка: {str(e)}")
                return HookResult(strategy=HookStrategy.CANCEL)

        return HookResult()

    def on_receive_message_hook(self, account, params):
        try:
            if not hasattr(params, "message") or not hasattr(params, "sender_id"):
                return HookResult()

            chat_id = str(params.peer_id)
            user_id = str(params.sender_id)
            current_time = time.time()

            if (chat_id in self.locked_users and 
                user_id in self.locked_users[chat_id] and
                current_time - self.last_reply_time.get(user_id, 0) > 1.0):
                
                reply_text = self.locked_users[chat_id][user_id]
                self.last_reply_time[user_id] = current_time
                
                # Создаем новое сообщение с ответом
                params.reply_message = reply_text
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
        except Exception as e:
            log(f"AutoReply error: {e}")
            
        return HookResult()
