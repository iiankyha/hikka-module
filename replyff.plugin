import os
import json
import time
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import run_on_ui_thread, log
from ui.bulletin import BulletinHelper

__id__ = "kastyan_autoreply"
__name__ = "AutoReply by Kastyan"
__description__ = "Автоматический ответ на сообщения. Команды: .lock @user текст, .unlock @user, .locklist"
__author__ = "Kastyan"
__version__ = "1.0"
__min_version__ = "11.12.0"
__icon__ = "plugin232/2"

class AutoReplyPlugin(BasePlugin):
    def on_plugin_load(self):
        # Используем стандартный путь для данных плагина
        self.data_file = os.path.join(
            os.environ['EXTERNAL_STORAGE'],
            'AYUGram',
            'plugin_data',
            f'{self.id}.json'
        )
        os.makedirs(os.path.dirname(self.data_file), exist_ok=True)
        
        self.locked_users = {}
        self.last_reply_time = {}
        self.load_data()
        
        self.add_on_send_message_hook()
        self.add_on_receive_message_hook()
        log(f"[AutoReply] Плагин загружен! Версия {self.version}")

    def load_data(self):
        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.locked_users = data.get('users', {})
                    self.last_reply_time = data.get('time', {})
            except Exception as e:
                log(f"[AutoReply] Ошибка загрузки: {e}")
                self.locked_users = {}
                self.last_reply_time = {}

    def save_data(self):
        try:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump({
                    'users': self.locked_users,
                    'time': self.last_reply_time
                }, f, indent=4, ensure_ascii=False)
        except Exception as e:
            log(f"[AutoReply] Ошибка сохранения: {e}")

    def on_send_message_hook(self, account, params):
        try:
            if not hasattr(params, "message") or not isinstance(params.message, str):
                return HookResult()

            msg = params.message.strip()
            
            # Обработка .lock
            if msg.startswith('.lock '):
                parts = msg[6:].split(maxsplit=1)
                if len(parts) < 2:
                    BulletinHelper.show_error("Формат: .lock @user текст")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                user_id = parts[0].strip('@')
                text = parts[1]
                chat_id = str(params.peer_id)
                
                if chat_id not in self.locked_users:
                    self.locked_users[chat_id] = {}
                
                self.locked_users[chat_id][user_id] = text
                self.save_data()
                
                BulletinHelper.show_success(f"Добавлен автоответ для @{user_id}")
                params.message = ""  # Удаляем оригинальное сообщение
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            
            # Обработка .unlock
            elif msg.startswith('.unlock '):
                user_id = msg[8:].strip().strip('@')
                chat_id = str(params.peer_id)
                
                if chat_id in self.locked_users and user_id in self.locked_users[chat_id]:
                    del self.locked_users[chat_id][user_id]
                    self.save_data()
                    BulletinHelper.show_success(f"Удалён автоответ для @{user_id}")
                else:
                    BulletinHelper.show_error("Пользователь не найден")
                
                params.message = ""
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            
            # Обработка .locklist
            elif msg == '.locklist':
                chat_id = str(params.peer_id)
                if chat_id not in self.locked_users or not self.locked_users[chat_id]:
                    BulletinHelper.show_info("Список автоответов пуст")
                else:
                    users = [f"@{uid}: {text}" for uid, text in self.locked_users[chat_id].items()]
                    BulletinHelper.show_info("Автоответы:\n" + "\n".join(users))
                
                params.message = ""
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
        except Exception as e:
            log(f"[AutoReply] Ошибка в on_send_message_hook: {e}")
            BulletinHelper.show_error(f"Ошибка: {str(e)}")
        
        return HookResult()

    def on_receive_message_hook(self, account, params):
        try:
            if not hasattr(params, "message") or not hasattr(params, "sender_id"):
                return HookResult()

            chat_id = str(params.peer_id)
            user_id = str(params.sender_id)
            current_time = time.time()

            if (chat_id in self.locked_users and 
                user_id in self.locked_users[chat_id] and
                current_time - self.last_reply_time.get(user_id, 0) > 1.0):
                
                reply_text = self.locked_users[chat_id][user_id]
                self.last_reply_time[user_id] = current_time
                
                # Создаем параметры для ответа
                if not hasattr(params, "reply_message"):
                    params.reply_message = reply_text
                else:
                    params.reply_message += f"\n{reply_text}"
                
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
        except Exception as e:
            log(f"[AutoReply] Ошибка в on_receive_message_hook: {e}")
            
        return HookResult()

    def on_plugin_unload(self):
        log("[AutoReply] Плагин выгружен")
        self.save_data()
