import json
import time
from base_plugin import BasePlugin
from android_utils import log
from ui.bulletin import BulletinHelper

__id__ = "kastyan_autoreply"
__name__ = "AutoReply by Kastyan"
__description__ = "Автоматический ответ. Команды: .lock @user текст, .unlock @user, .locklist"
__author__ = "Kastyan"
__version__ = "4.0"
__min_version__ = "11.12.0"
__icon__ = "plugin232/2"

class AutoReplyPlugin(BasePlugin):
    def on_plugin_load(self):
        log("[AutoReply] Плагин инициализирован")
        self.locked_users = {}
        self.last_reply = {}
        self.load_data()
        BulletinHelper.show_success("AutoReply загружен")

    def load_data(self):
        try:
            # Чтение данных из простого JSON-файла
            data = json.loads(self.read_file("autoreply_data.json") or "{}")
            self.locked_users = data.get("users", {})
            self.last_reply = data.get("time", {})
            log(f"[AutoReply] Загружено {len(self.locked_users)} чатов")
        except Exception as e:
            log(f"[AutoReply] Ошибка загрузки: {e}")

    def save_data(self):
        try:
            data = {
                "users": self.locked_users,
                "time": self.last_reply
            }
            self.write_file("autoreply_data.json", json.dumps(data))
            log("[AutoReply] Данные сохранены")
        except Exception as e:
            log(f"[AutoReply] Ошибка сохранения: {e}")

    def read_file(self, filename):
        """Безопасное чтение файла"""
        try:
            with open(f"/data/data/com.radolyn.ayugram/files/{filename}", "r") as f:
                return f.read()
        except:
            return None

    def write_file(self, filename, content):
        """Безопасная запись файла"""
        try:
            with open(f"/data/data/com.radolyn.ayugram/files/{filename}", "w") as f:
                f.write(content)
        except Exception as e:
            log(f"[AutoReply] Ошибка записи: {e}")

    def on_send_message(self, account, peer_id, message):
        try:
            msg = message.strip()
            
            if msg.startswith('.lock ') and len(msg.split()) >= 3:
                _, user, *text = msg.split(maxsplit=2)
                chat_id = str(peer_id)
                self.locked_users.setdefault(chat_id, {})[user.strip('@')] = text[0]
                self.save_data()
                BulletinHelper.show_success(f"Добавлен ответ для {user}")
                return ""  # Удаляем сообщение

            elif msg.startswith('.unlock '):
                user = msg.split()[1].strip('@')
                chat_id = str(peer_id)
                if chat_id in self.locked_users and user in self.locked_users[chat_id]:
                    del self.locked_users[chat_id][user]
                    self.save_data()
                    BulletinHelper.show_success(f"Удалён ответ для @{user}")
                else:
                    BulletinHelper.show_error("Пользователь не найден")
                return ""

            elif msg == '.locklist':
                chat_id = str(peer_id)
                if chat_id in self.locked_users and self.locked_users[chat_id]:
                    users = [f"@{u}: {t}" for u, t in self.locked_users[chat_id].items()]
                    BulletinHelper.show_info("Автоответы:\n" + "\n".join(users))
                else:
                    BulletinHelper.show_info("Список пуст")
                return ""

        except Exception as e:
            log(f"[AutoReply] Ошибка команды: {e}")
            BulletinHelper.show_error(f"Ошибка: {e}")
        
        return None

    def on_message(self, account, peer_id, sender_id, message):
        try:
            chat_id = str(peer_id)
            user_id = str(sender_id)
            current_time = time.time()

            if (chat_id in self.locked_users and 
                user_id in self.locked_users[chat_id] and
                current_time - self.last_reply.get(user_id, 0) > 1.0):
                
                self.last_reply[user_id] = current_time
                return self.locked_users[chat_id][user_id]
                
        except Exception as e:
            log(f"[AutoReply] Ошибка ответа: {e}")
        
        return None

    def on_plugin_unload(self):
        log("[AutoReply] Плагин выгружен")
        self.save_data()
